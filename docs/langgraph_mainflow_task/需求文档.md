我要做一个基于 LangGraph 的ai数据库分析师

# 注意事项
注意子母flow的设计来避免单个LangGraph文件过长,也注意脚本的合理分离式设计.
构建LangGraph的过程中注意使用context7 学习LangGraph的最新知识避免不必要的错误.
query脚本案例保存在 sample_query文件夹中.
注意可以使用.env文件中的内容来真实链接Bigquery以及LLM.
构建LangGraph的过程中需要在langsmith留下记录,
注意执行过程中出现任何错误都要使用context7 来获取最新信息
我的测试主要在LangGraph studio中进行.
注意一定不能使用虚假数据和演示目的的demo, 你的目的是绝对不能偷懒, 做出一个商业级别的ai数据库分析师
除了代码注释使用中文外, 其他所有代码和print或任何LangGraph内代码,任何函数和变量名,prompt,输出等一切都要使用英语.

# 第一步,检索
输入:用户问题+十个案例问题
接受用户输入的问题, 用LLM对问题进行分析置信度评分和归类.
主要的类别就是上文提到的十个问题.
情况一:如果用户的问题和十个问题中的任何一个或多个近似度很高(用LLM来判断相似度), 则将近似问题的query脚本作为第二步的输入
情况二:如果用户的问题和任何问题都不相关, 则用一个状态说明情况, 进入第二步

其他建议增强的问题分析包含：
- 参数提取：识别品牌、时间范围、类别等业务实体
- 复杂度评估：判断单一查询还是组合查询
- 置信度评分：量化匹配质量

输出:命中案例问题的脚本+状态

# 第二步,脚本
输入:命中案例问题的脚本+状态

## query脚本生成器, LLM_A
情况一:第一步的输出中传入近似问题的脚本(若不匹配,则可以为空), 则依据上文提到的query脚本也作为llm的输入以作为参考,  请求LLM_A生成一个新的query脚本.脚本命名为时间戳以防止重复.
LLM_A补充:
输入:  (可选:其他程序或工具额外的输入)+query脚本+脚本生成prompt,
输出: 一个正确命名和准确有效的py query脚本文件

## 脚本执行器
需要一个能和和Bigquery真实对接的tools执行LLM_A生成的脚本, 并记录执行的输出结果
这个执行器需要有以下功能：
- execute_bigquery_script: 一个能够接收Python脚本字符串并执行其中BigQuery查询的工具。
- estimate_query_cost_and_size: 一个在执行前预估查询将处理的数据量的BigQuery API工具。BigQuery支持 "dry run" 功能，这正是为此设计的, 注意如果dry run显示超过 200G的全量查询, 则直接停止, 把数据量过大这个信息传递到LLM_A然后重新生成query脚本。

## 脚本执行结果审判机,LLM_B

LLM_B 输入: 脚本执行器的执行结果+脚本执行器所执行的脚本+用户问题,
LLM_B输出:判断query脚本的是否能正常执行. 数据量大小是否超过了 100k token, 与用户问题的相关性和质量这几个指标. yes表示这是个有效可靠的query脚本. 若是no则加上建议作为LLM_A的输入, 重复执行LLM_A并重新生成py query.


## 脚本解读器, LLM_C
当LLM_B yes通过后, 请求LLM_C向用户阅读或解释这个query脚本

LLM_C补充:
输入:是LLM_B验证通过后的query脚本+LLM_B的输出, 输出是让llm用简单易懂,当前query脚本的简单逻辑和主要作用, 用markdown的表格展示5条示例数据,让用户可以二次判断query语句和用户问题的相关度是否符合要求.
这里要注意用户不是程序员, 你的描述要尽量简单易懂.


## 用户二次抉择
把LLM_C的输出展现给用户看, 给用户提供两个选项, 生成报告或重新生成query脚本, 若用户选择继续, 则进行第三步. 若用户选择重新生成query则需要执行情况三, 直到用户任何query脚本.


# 第三步,报告生成

## 报告格式建议器, LLM_D
用一个human_in_loop 展示query执行后的原始数据(注意用markdown的表格形式展现),
并让用户选择他想将原始数据生成饼图, 流程图, 条形图, 思维导图等等(图表类型的推荐: 系统是仅仅提供选项（饼图、条形图等），并且调用LLM能根据数据本身的特点（例如时间序列数据推荐折线图，分类数据推荐条形图）为用户提供智能推荐),

## 报告格式生成器, LLM_F
最终根据用户的选择来使用vega还是mermaid还是mindmap.来生成对应的网页报告


# 其他信息
## 两个核心数据库
thrasio-dev-data-wh-7ee095.reporting_us.rpt_fct_order
thrasio-dev-data-wh-7ee095.reporting_us.rpt_dim_item

rpt_dim_item的schema如下
| Field name | Type | Mode |
| :--- | :--- | :--- |
| channel_id | STRING | NULLABLE |
| item_id | INTEGER | NULLABLE |
| sub_brand | STRING | NULLABLE |
| parent_asin | STRING | NULLABLE |
| is_current | BOOLEAN | NULLABLE |
| is_item_inactive | STRING | NULLABLE |
| item_sku | STRING | NULLABLE |
| listing_status | STRING | NULLABLE |

rpt_dim_item 的案例数据如下
channel_id	item_id	sub_brand	parent_asin	is_current	is_item_inactive	item_sku	listing_status
B09JPHT1XH	130987	B-Six	B09JPK9WHZ	true	F	BSX-SKADEXCO-AMZ	Discontinued
B091BBKX9G	45435	B-Six	None	true	T	NP-JUNGLEFEVER-STAR-SZB	Discontinued
B07XQ52GY3	59966	BARTSTR	B07XQ52GY3	true	T	BRT-OTR-BTMT-XXLBLK-UK	Divested
B075X2XKBZ	20517	BEARD KING	B075X2XKBZ	true	T	FA-TTLZ-I2QQ	Divested
B076W1CRJH	8349	Becky Cameron	None	true	T	B076W1CRJH	Discontinued
B07QQFWF6B	53621	Checkered Chef	B07QQFWF6B	true	T	QT03252	Divested
B09DGVCQ7R	125919	DMD	B0BSGB4ZKG	true	F	DMD-HOK-PRBDSHT-TXLLTGRY-1	Active
B00YGJE7FK	89425	DRIVE AUTO PRODUCTS	None	true	T	BF-IQB2-OZV5	Discontinued

rpt_fct_order表的schema如下
| Field name | Type | Mode |
| :--- | :--- | :--- |
| sales_channel_id | INTEGER | NULLABLE |
| sales_channel_type_id | INTEGER | NULLABLE |
| market_region_id | INTEGER | NULLABLE |
| order_date | DATE | NULLABLE |
| channel_id | STRING | NULLABLE |
| item_id | INTEGER | NULLABLE |
| units | INTEGER | NULLABLE |
| item_promotion_discount_usd | FLOAT | NULLABLE |
| ship_promotion_discount_usd | FLOAT | NULLABLE |
| tax_usd | FLOAT | NULLABLE |
| gross_sales_usd | FLOAT | NULLABLE |
| gross_revenue_usd | FLOAT | NULLABLE |
| cogs_usd | FLOAT | NULLABLE |
| refund_usd | FLOAT | NULLABLE |
| referral_fee_refund_usd | FLOAT | NULLABLE |
| refund_administration_fee_usd | FLOAT | NULLABLE |
| warehousing_cost_usd | FLOAT | NULLABLE |
| transportation_cost_usd | FLOAT | NULLABLE |
| fba_inbound_placement_fee_usd | FLOAT | NULLABLE |
| amz_fba_fee_usd | FLOAT | NULLABLE |
| referral_fee_order_usd | FLOAT | NULLABLE |
| net_revenue_usd | FLOAT | NULLABLE |
| gross_profit_usd | FLOAT | NULLABLE |

rpt_fct_order 的案例数据如下
sales_channel_id,sales_channel_type_id,market_region_id,order_date,channel_id,item_id,units,item_promotion_discount_usd,ship_promotion_discount_usd,tax_usd,gross_sales_usd,gross_revenue_usd,cogs_usd,refund_usd,referral_fee_refund_usd,refund_administration_fee_usd,warehousing_cost_usd,transportation_cost_usd,fba_inbound_placement_fee_usd,amz_fba_fee_usd,referral_fee_order_usd,net_revenue_usd,gross_profit_usd
1,1,1,2025-02-01,B01LYC1XSM,118014,1153,10408.099999999999,1236.9700000000014,5777.45,91042.409999999989,79397.340000000011,17070.11919999999,4696.5699999999988,697.19999999999982,143.10000000000002,0,11.17,1867.8600000000006,11499.369999999997,12063.14,74700.770000000019,34622.2408
1,1,1,2025-02-01,B0BN2GJVWJ,109167,28,6.25,9.74,41.469999999999992,595.46000000000015,579.47000000000014,99.680839999999975,0,0,0,0,5.88,0,161.55999999999997,86.1,579.47000000000014,232.12916

## query脚本生成建议
注意Bigquery的输入将要全部发给LLM. 而LLM是有token限制的, 一般不能超过600000个英文字符也就是 100k tokens. 否则大模型的输出结果会不稳定.
所以query语句要尽量遵循以下原则
过滤语句中,若能显示统计数量则优先数字形式的数量, 不要返回过滤后的完整数据
注意避免返回与用户问题无关的列
其他任何你觉得有帮助的建议